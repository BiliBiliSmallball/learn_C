#include "system.h"
#include "93C46.h"

/**********************************************************
*功    能：93C46端口初始化
*参    数：无
*返 回 值：无
**********************************************************/
void AT93C46_Hardwarw_Init(void)
{
    P6_Mode_PullUp(SPI_CS_PIN|SPI_SCL_PIN|SPI_DO_PIN);
	  P6_Mode_HighZ(SPI_DI_PIN);
    CS(0);//初始化端口
    SCL(0);
    DO(1);
}

/**********************************************************
*功    能：写入数据
*参    数：indata
*返 回 值：无
**********************************************************/
void Write46(unsigned char indata)               
{
   unsigned char i;
	
   for(i = 0; i < 8; i++)
   {
      DO(((indata & 0x80)>>7));// 先移入高位
      SCL(1);
	  Delay_us(1);
      indata <<= 1;
      SCL(0);  
	  Delay_us(1);
   }
   DO(1);
}

/**********************************************************
*功    能：读出数据 
*参    数：无
*返 回 值：out_data
**********************************************************/     
unsigned char Read46(void)         
{
   unsigned char i, out_data;
   for(i = 0; i < 8; i++)
   {
      SCL(1);
	  Delay_us(1);
      out_data <<= 1;
      SCL(0);
	  Delay_us(1);
      out_data |= (unsigned char)DI();
   }
   return(out_data);
}

/**********************************************************
*功    能：发送一个位
*参    数：IO 1bit
*返 回 值：无
**********************************************************/     
void Sendbit (uint8_t IO)            
{
	//IO=IO&0x80;
	if(IO&0x01)
		DO(1);
    else 
		DO(0);	 
    SCL(1);
	Delay_us(1);
	SCL(0);      //写入脉冲
}

/**********************************************************
*功    能：读写功能操作函数
           设定 写允许 功能函数， 控制码 1 00 11XXXXX  
           写入数据前，需要改变EWEN的状态
*参    数：无
*返 回 值：无
***********************************************************/     
void EWEN46 (void)            
{
	CS(0);
	SCL(0);
    Delay_us(1);  
    CS(1);                      //片选
    Sendbit(1);                //发送起始位
    Sendbit(0);                //发送操作码高位
    Write46(0x60);             //将地址信息与操作码低位整合，一起发送
    CS(0);                      //取消片选
	Delay_us(1);
}


/**********************************************************
*功    能：设定 写禁止 功能函数， 
            控制码 1 00 00XXXXX  数据写入完成后保护数据
*参    数：无
*返 回 值：无
***********************************************************/     
void EWDS46 (void)            
{
	Delay_us(1);
	CS(1);
	Sendbit(1);
	Sendbit(0);
	Write46(0x00);
	CS(0);
	Delay_us(1);
}

/**********************************************************
*功    能：设定 擦除全部 功能函数，控制码 1 00 10XXXXX  
           抹除数据
*参    数：无
*返 回 值：无
***********************************************************/     
void ERAL46 (void)            
{
	CS(0);
	Delay_us(1);
	CS(1);
	Sendbit(1);
	Sendbit(0);
	Write46(0x40);
	CS(0);
	Delay_us(1);
}

/**********************************************************
*功    能：用户接口功能函数
           指定地址，读取一个字节，控制码 1 10 XXXXXXX           
*参    数：无
*返 回 值：无
***********************************************************/    
char AT93C46_Read_Byte (unsigned char addr)       
{                                      //七位地址对应8bit模式    
	CS(0);
    SCL(0);
	Delay_us(1);
	CS(1);                              //片选开

	Delay_us(1);                          //延时
	Sendbit(1);                        //发送开始位
	Sendbit(1);                        //发送操作码高位
	Write46(0x7F&addr);                //整合地址与操作码地位发送
	addr=Read46();                     //获取数据
	CS(0);
	Delay_us(1);                      //关闭片选
	return (addr);                     //返回数据
}

/**********************************************************
*功    能：指定地址，写入一个字节，控制码 1 01 XXXXXXX          
*参    数：无
*返 回 值：无
***********************************************************/  
void AT93C46_Write_Byte (unsigned char addr,char thedata)    
{                                            //七位地址对应8bit模式
	unsigned int time=0;                     //定义超时变量
	unsigned char i=0;                       //定义写入循环变量
	do
	{                                        //开始三次写入循环，成功写入跳出
		CS(0);
        SCL(0);                                
		CS(1);                                //开片选信号
		Delay_us(1);
		EWEN46();                            //开写入允许
		Delay_us(1);                           //延时
		CS(1);                                //重新开片选
		Delay_us(1);
		Sendbit(1);                          //发送开始码
		Sendbit(0);                          //发送操作码高位
		Write46(0x80|addr);                  //整合操作码低位与七位地址
		Write46(thedata);                    //写入数据
		CS(0);                                //关闭片选
		Delay_us(1);                         //延时
		CS(1);                                //重开片选
		do                                   //忙判别
		{
			if(time>500) break;              //如果期间有问题，超时退出
			time++;
		}while(!DI());                         //如果器件准备就绪，取消循环
		CS(0);                                //关闭片选
		Delay_us(1);
		if(AT93C46_Read_Byte(addr)==thedata) break; //判断写入是否正确，正确退出循环，否则写入三次
			i++;
	}while(i<3);                             //写入三次自动退出
}

/**********************************************************
*功    能：在93C46里面的指定地址开始读出指定个数的数据
*参    数：ReadAddr/开始读出的地址 对24c01为0~127；
           Buffer/数据数组首地址；Buf_len/要读出数据的个数
*返 回 值：无
**********************************************************/
void AT93C46_Read(uint16_t ReadAddr,uint8_t *Buffer,uint16_t Buf_len)
{
    while(Buf_len)
	{
		*Buffer++ =AT93C46_Read_Byte(ReadAddr++);
		Buf_len--;
	}
}

/**********************************************************
*功    能：在93C46里面的指定地址开始写入指定个数的数据
*参    数：WriteAddr/开始写入的地址 对24c01为0~127；
           Buffer/数据数组首地址；Buf_len/要写入数据的个数
*返 回 值：无
********************************************* *************/
void AT93C46_Write(uint16_t WriteAddr,uint8_t *Buffer,uint16_t Buf_len)
{
	while(Buf_len--)
	{
		AT93C46_Write_Byte(WriteAddr,*Buffer);
		WriteAddr++;
		Buffer++;
	}
}
/***********************************************************************
*功    能：检查93C46是否正常，这里用了24XX的最后一个地址(255)来存储标志字，
           如果用其他24C系列,这个地址要修改
*参    数：WriteAddr/开始写入的地址 对24c01为0~127；
           Buffer/数据数组首地址；Buf_len/要写入数据的个数
*返 回 值：1/检测失败；0/检测成功
*************************************************************************/
uint8_t AT93C46_Check(void)
{
	uint8_t temp = 0;
	temp =AT93C46_Read_Byte(255);
	if(temp == 0x55)
		return 0;
	else 
	{
		AT93C46_Write_Byte(255,0x55);
		temp =AT93C46_Read_Byte(255);
		if(temp == 0x55)
			return 0;
	}
	return 1;
}
